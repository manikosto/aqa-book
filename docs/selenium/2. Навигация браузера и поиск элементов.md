### Навигация браузера

**Открытие страницы**  
Первое, что вы захотите сделать после того как запустите браузер, это открыть сайт. Это можно сделать используя метод **get()**:

```python
driver.get("https://example.ru")
```

**Переход назад по странице**  
Часто нажав не туда или просто для удобства, мы используем кнопку "Назад" в браузере. Это та самая стрелочка влево ◀️ около адресной строки браузера. Для того чтобы совершить нажатие нам понадобиться метод **back()**.

```python
driver.back()
```

**Переход вперед по странице**  
В данном случае ситуация аналогична переходу "Назад" по странице, только в этом случае переход по странице совершается вперед. Для этого нам необходимо использовать метод **forward()**.

```python
driver.forward()
```

### Получение заголовка страницы

**Перезагрузка страницы**  
Очень и очень часто во время работы или простого серфинга сайтов, мы используем кнопку для обновления страницы. Для того чтобы обновить страницу используя Selenium нужно использовать метод **refresh()**.

```python
driver.refresh()
```

Ранее мы разобрали как получить URL-адрес веб-страницы, но иногда нам нужно получать значение тега **<titile/>** на веб-странице.  
  
Как пример все для той же проверки правильного открытия страницы. Это можно сделать обратившись к атрибуту **title**.

```python
driver.title
```

По аналогии с получением URL-адреса, мы можем записать значение title в переменную для дальнейшего использования.

```python
PAGE_TITLE = driver.title # Записываем значение title в переменную page_title

print("Title страницы: ", PAGE_TITLE) # Выводим значение переменной на экран
```

### Получение всего содержимого страницы

Чтобы получить весь html-код страницы для дальнейших манипуляций, существует атрибут **page_source**.

```python
PAGE_SOURCE = driver.page_source # Записываем в переменную всю веб-страницу

print(PAGE_SOURCE) # Печатаем HTML-код в терминал
```

### Получение текущего URL страницы

В дальнейшем, вам пригодится команда для получения URL-адреса страницы из адресной строки браузера, например для того чтобы убедиться в том, что действительно открыта нужная вам веб-страница.  
  
Это можно сделать обратившись к атрибуту **current_url**.

```python
driver.current_url
```

Для удобства Вы можете записать его в переменную для дальнейшего использования:

```python
PAGE_URL = driver.current_url # Получаем текущий URL-адрес в переменную

print(PAGE_URL) # Выводим значение переменной
```

### Валидация через Assert

В автоматизации, нам необходимо проверять правдивость данных, соответствуют ли они ожидаемому результату или нет. Для этого используются либо условные операторы, либо чуть более интересная конструкция называемая **assert.**  
  
Данная конструкция имеет следующий вид:

```python
a = 2
b = 2
assert a == b, "A не равно Б"
```

Т.е если утверждение правдивое, то все хорошо, если же нет, то будет ошибка с указанным после запятой текстом.  
  
Давайте рассмотрим более реальный пример, предположим, что мы заранее знаем Title страницы, например для страницы **https://dzen.ru/**  
  
title - в данном случае **“Дзен”**

```python
driver.get("https://dzen.ru") # Открываем страницу

assert driver.title == "Дзен", "Страница не открылась"
```

### Спящий код

Зачастую для проверки каких-то вещей руками, нужно притормозить код, чтобы успеть сделать действия в браузере руками. Для таких целей необходимо импортировать модуль time и его метод **time.sleep()**.

```python
import time

time.sleep(5) # В качестве аргумента принимает кол-во секнуд для паузы
```

### Что такое WebElement

Поиск элементов на странице будет занимать немалую часть времени всего процесса автоматизации, поэтому этой теме нужно уделить особое внимание.  
  
Начнем с определения того, что такое элемент с точки зрения автоматизации и с точки зрения самого Selenium.  

> **WebElement** - это любой объект на странице найденный с помощью Selenium, такой как кнопка, поле ввода и т.д. Самое важное, что это объект, который имеет тип: **WebElement** (нужно просто это понимать).


### Поиск веб-элементов с помощью By

Существует множество способов поиска элементов на странице, мы рассмотрим самые удобные и эффективные.  
  
Первое что стоит изучить, это принцип поиска по простейшим атрибутам, возьмем к примеру:  
  
1. ID
2. CLASS_NAME
3. TAG_NAME
  
Для начала работы, нам необходимо импортировать новый для нас модуль **By**

```python
from selenium.webdriver.common.by import By
```

Отлично, теперь мы готовы к свершениям и в первую очередь научимся искать один веб-элемент.

**Поиск одного элемента**  
Для поиска одного элемента, у обьекта **driver** есть специальный метод **find_element()**.  
  
Аргументы метода:  

- **Способ поиска** - например, используя наш новый модуль By: **By.ID**
- **Значение атрибута** - указывается значение атрибута в соотвествии со способом поиска

Разберем пример, при котором мы ищем ниже описанное поле ввода input:

```python
<input id=”login_field” class="login"/>
```

Посмотрим на несколько примеров поиска по ранее упомянутым атрибутам

```python
driver.find_element(By.ID, "login_field") # Поиск по id атрибуту

driver.find_element(By.CLASS_NAME, "login") # Поиск по имени класса

driver.find_element(By.TAG_NAME, "input") # Поиск по имени тега
```

**Но что же вернет мне результат поиска элемента?**  
Ранее мы познакомились с таким обьектом как WebElement, давайте посмотрим как он выглядит.  
  
Для начала выполним простой код для поиска элемента:

```python
driver.get("https://testautomationpractice.blogspot.com") # Откроем тестовую страницу

ELEMENT = driver.find_element(By.ID, "Wikipedia1_wikipedia-search-input")

print(ELEMENT)
```

В результате вывода мы получим следующую картину:

```python
<selenium.webdriver.remote.webelement.WebElement (session="7285b48ff604d43b1e6c42166802cd00", element="e56e1acc-e470-4463-b76f-46e8b20b69a7")>
```

Вот таким образом и выглядит наш обьект с типом WebElement

### Поиск нескольких веб-элементов

Мы уже научились искать один элемент, но иногда, нам понадобиться найти множество элементов, и сделать это можно с помощью метода **find_elements().**  
  
Данный метод имеет те же аргументы, что и **find_element()**, но главное различие в том, что **find_elements()** возвращает список элементов.  
  
Пример:

```python
LIST_OF_H1_TAGS = driver.find_elements(By.TAG_NAME, "h2")

print(LIST_OF_H1_TAGS)
```

В результате мы получим стандартный список, в котором будут лежать все веб-элементы имеющий тег **h2**:

```python
[<selenium.webdriver.remote.webelement.WebElement (session="aa2baed948cbe55eedad6d34832f571a", element="b4573195-37c8-4300-a474-a7b0e459bb50")>,
<selenium.webdriver.remote.webelement.WebElement (session="aa2baed948cbe55eedad6d34832f571a", element="6f7520e1-9dda-4b7f-8c66-73f464a107f3")>,
<selenium.webdriver.remote.webelement.WebElement (session="aa2baed948cbe55eedad6d34832f571a", element="2d40c5e9-4a00-4a7d-a367-b99af8aea06b")>,]
```

**Как можно работать с таким списком?**  
Да как и с обычными списками в Python, например мы хотим спарсить все **h2** заголовки со страницы:

```python
elements = driver.find_elements(By.TAG_NAME, "h2") # Находим все элементы h2
for element in elements: # Перебираем список элементов h2
    print(element.text) # Выводим текст элементов h2
```

Тут можно заметить, что я получаю атрибут **text**, он существует у всех элементов в которых содержится какой-либо текст, что логично)  
  
Или к примеру, если мы хотим получить определенный веб-элемент из списка, то просто обращаемся по индексу

```python
ELEMENTS = driver.find_elements(By.TAG_NAME, "h2") # Находим все элементы h2
print(ELEMENTS[2])
```

### Поиск веб-элементов без By

Ранее мы использовали стандартные методы, затем научились использовать пакет **By,** но существует еще один способ, как по мне, он максимальной прост, понятен и удобен.  
  
Тут все просто, сразу приведу пример:

```python
driver.find_element("id", "login_field")
```

То есть вместо пакета **By**, мы используем текстовые значения и нет необходимости делать какие либо дополнительные импорты.  
  
Список обозначений для использования вместо **By**:

```python
ID = "id"
XPATH = "xpath"
LINK_TEXT = "link text"
PARTIAL_LINK_TEXT = "partial link text"
NAME = "name"
TAG_NAME = "tag name"
CLASS_NAME = "class name"
CSS_SELECTOR = "css selector"
```

### Первый клик

Основываясь на изученном ранее поиске элементов давайте научимся самому важному способам манипуляции с веб-элементами, клику!  
  
Клик на элемент применяется непосредственно к найденному элементу страницы и имеет специальный метод **click()**

```python
SEARCH_BUTTON = driver.find_element("id", "example") # Поиск элемента

SEARCH_BUTTON.click() # Клик по элементу
```